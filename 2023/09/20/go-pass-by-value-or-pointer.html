<!DOCTYPE html>
<html lang="en">
<!-- Beautiful Jekyll 6.0.1 | Copyright Dean Attali 2023 -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>Pass Go Structs and Arrays as Pointers, Everything Else as Values</title>

  
  <meta name="author" content="Percy Wegmann">
  

  <meta name="description" content="Don&apos;t Overthink It">

  

  

  

  

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="Lessons Learned">
  <meta property="og:title" content="Pass Go Structs and Arrays as Pointers, Everything Else as Values">
  <meta property="og:description" content="Don&apos;t Overthink It">

  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="Percy Wegmann">
  <meta property="og:article:published_time" content="2023-09-20T00:00:00-05:00">
  <meta property="og:url" content="https://blog.percywegmann.com/2023/09/20/go-pass-by-value-or-pointer.html">
  <link rel="canonical" href="https://blog.percywegmann.com/2023/09/20/go-pass-by-value-or-pointer.html">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  <meta property="twitter:title" content="Pass Go Structs and Arrays as Pointers, Everything Else as Values">
  <meta property="twitter:description" content="Don&apos;t Overthink It">

  

  


  

  
    
      <!-- Pixel Code for https://app.tinyanalytics.io/ -->
<script defer src="https://app.tinyanalytics.io/pixel/OmLIT5Hw8bHakFb8"></script>
<!-- END Pixel Code -->
    
  

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="https://blog.percywegmann.com/">Lessons Learned</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto"></ul>
  </div>

  

  

</nav>





  <!-- TODO this file has become a mess, refactor it -->







<header class="header-section ">

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Pass Go Structs and Arrays as Pointers, Everything Else as Values</h1>
          
            
              <h2 class="post-subheading">Don't Overthink It</h2>
            
          

          
            <span class="post-meta">Posted on September 20, 2023</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <p>At work, we recently started a discussion on when to pass function arguments as pointers (by reference) and when to pass by value. A related (but subtly different) question is whether to use pointer <a href="https://go.dev/ref/spec#Method_declarations">receivers</a> or value receivers. Unfortunately, Go’s documentation and standard library aren’t clear on this point, and Google’s Go styleguide has <a href="https://google.github.io/styleguide/go/decisions#pass-values">some guidance</a>, but it’s a bit too handwavy.</p>

<p>Let’s start with Google’s styleguide.</p>

<blockquote>
  <p>Do not pass pointers as function arguments just to save a few bytes. If a function reads its argument x only as <em>x throughout, then the argument shouldn’t be a pointer. Common instances of this include passing a pointer to a string (</em>string) or a pointer to an interface value (*io.Reader). In both cases, the value itself is a fixed size and can be passed directly.</p>
</blockquote>

<blockquote>
  <p>This advice does not apply to large structs, or even small structs that may increase in size. In particular, protocol buffer messages should generally be handled by pointer rather than by value. The pointer type satisfies the proto.Message interface (accepted by proto.Marshal, protocmp.Transform, etc.), and protocol buffer messages can be quite large and often grow larger over time.</p>
</blockquote>

<p>Okay, so scalar value types like <code class="language-plaintext highlighter-rouge">string</code>, and interfaces, are clear - pass by value. Arrays are also clear - copying them is expensive, so pass them by reference. Structs … less so. Large (whatever that means) or growable structs should be passed by reference, but small(?) structs should be passed by value. What’s the cutoff, is it a question of performance?</p>

<blockquote>
  <p>Note: There is a lot of misinformation about whether passing a value or a pointer to a function can affect performance. The compiler can choose to pass pointers to values on the stack as well as copying values on the stack, but these considerations should not outweigh the readability and correctness of the code in most circumstances. When the performance does matter, it is important to profile both approaches with a realistic benchmark before deciding that one approach outperforms the other.</p>
</blockquote>

<p>Okay, so stuff like stack vs heap allocation, and copying, matters from a performance perspective. We’ll get back to this later.</p>

<p>What about the standard library? Here, I’m most familiar with the <a href="https://pkg.go.dev/net">net</a>, <a href="https://pkg.go.dev/net/http">net/http</a> and <a href="https://pkg.go.dev/crypto/tls">crypto/tls</a> packages. In these packages, most of the value types are things like <code class="language-plaintext highlighter-rouge">net.IP</code> or <code class="language-plaintext highlighter-rouge">http.Header</code> which aren’t structs, but rather slices or maps or scalars of some sort, and these are always passed as values (not pointers). The struct types are mostly stateful mutable things like <code class="language-plaintext highlighter-rouge">net.TCPConn</code> or <code class="language-plaintext highlighter-rouge">http.Server</code>, and often they’re wrapped by interfaces like <code class="language-plaintext highlighter-rouge">net.Conn</code>. The concrete structs are always passed by pointer, and the interfaces are always passed by value.</p>

<p>Taken together with the Google styleguide, we arrive at the below candidate heuristics:</p>

<hr />

<ol>
  <li>Types that are not structs or arrays, i.e. scalars, slices, maps, interfaces should be passed by value.</li>
  <li>Arrays and big or mutable structs should be passed by pointer.</li>
</ol>

<hr />

<p>Still, I’m left wondering about the elusive “small” structs. Thankfully, my hunt for small structs bags a nice <code class="language-plaintext highlighter-rouge">Animal</code> in the <a href="https://pkg.go.dev/encoding/json#example-Unmarshal">example</a> for <code class="language-plaintext highlighter-rouge">json.Unmarshal</code>. Presumably, if the example were an animal decoder function rather than just a <code class="language-plaintext highlighter-rouge">main</code> function, it might look like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Animal</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span>  <span class="kt">string</span>
	<span class="n">Order</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">decodeAnimal</span><span class="p">(</span><span class="n">jsonBlob</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="n">Animal</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">animal</span> <span class="n">Animal</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">jsonBlob</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">animal</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">animal</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I’ve definitely seen functions like this in use at work, and I see a similar pattern used in the Go <a href="https://go.dev/doc/tutorial/database-access">SQL tutorial</a>. <code class="language-plaintext highlighter-rouge">Animal</code> is a small struct and returning it as a value allows for stack allocation (maybe?). We’ll get back to this later.</p>

<p>So at this point, our candidate heuristics are:</p>

<hr />

<ol>
  <li>Types that are not arrays or structs, i.e. scalars, slices, maps, interfaces should be passed by value.</li>
  <li>Arrays and big or mutable structs should be passed by pointer</li>
  <li>Small structs should be passed by value.</li>
</ol>

<hr />

<p>But wait, there’s more! When talking about the closely related method receivers, the Google styleguide provides several recommendations on when to use pointer receivers, including:</p>

<blockquote>
  <p>There are cases where you must use a pointer value. In other cases, pick pointers for large types or as future-proofing if you don’t have a good sense of how the code will grow, and use values for simple plain old data</p>
</blockquote>

<blockquote>
  <p>If the method needs to mutate the receiver, the receiver must be a pointer.</p>
</blockquote>

<blockquote>
  <p>If the receiver is a struct containing fields that cannot safely be copied, use a pointer receiver. Common examples are sync.Mutex and other synchronization types.</p>
</blockquote>

<p>Okay, cool, so “small” structs should be treated as values, unless they need to be mutated, or they contain fields that can’t be safely copied, or they may eventually evolve into something that meets one of the above criteria. At this point, it seems simpler to me to just pass all structs as references, what rationale is there for not doing this?</p>

<p>According to the Google styleguide</p>

<blockquote>
  <p>If the receiver is a “small” array or struct that is naturally a value type with no mutable fields and no pointers, a value receiver is usually the right choice.</p>
</blockquote>

<p>Here they give the example of <code class="language-plaintext highlighter-rouge">time.Time</code>, which is explicitly defined as an immutable type with mutators that return new <code class="language-plaintext highlighter-rouge">time.Time</code> instances. Another good example of such a type is Shopspring’s <a href="https://github.com/shopspring/decimal">decimal</a> type. It seems to me here that the defining characteristic of these types is not that they’re small, but rather that their APIs have been designed to hide their fields from consumers and instead expose mutators that return new values. In essence, these feel a lot like built-in value types such as <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">int</code>, etc, and if Go were a more extensible language these might actually behave just like those types. I can get on board with this.</p>

<blockquote>
  <p>For methods that will call or run concurrently with other functions that modify the receiver, use a value if those modifications should not be visible to your method; otherwise use a pointer.</p>
</blockquote>

<p>This sounds plausible in principle, but for me, it comes up very rarely in practice. Also, the devil is in the details. In the one specific case I can think of, the type in question was in fact a slice. Passing a slice by value doesn’t cause the underlying array to be copied, so I had to explicitly copy it before passing it along. Even if I had wrapped the slice in a struct as shown below, passing the struct by value wouldn’t have helped because both structs would still have been referring to the same underlying array.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">thing</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">s</span> <span class="p">[]</span><span class="n">otherThing</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So here’s another rub - <em>passing a struct by value doesn’t actually guarantee that you won’t have shared state</em>, if the fields on the struct are themselves pointers or pointer-like things (e.g. maps and slices). If you need to make sure you have a copy, you should really explicitly make a deep copy yourself. So yeah, this recommendation doesn’t hold water.</p>

<blockquote>
  <p>If the receiver is a “large” struct or array, a pointer receiver may be more efficient.</p>
</blockquote>

<p>The corrolary to this is that for “small” structs, passing by value may be more efficient, presumably because small structs can be stack allocated when passed by value. In practice though, this isn’t the case, both because a) Go’s escape analysis is smart enough to stack allocate even pointer variables in some cases and b) interacting with APIs that take <code class="language-plaintext highlighter-rouge">interface{}</code> parameters like <code class="language-plaintext highlighter-rouge">json.Unmarshal()</code> and <code class="language-plaintext highlighter-rouge">fmt.Println()</code> causes even small struct values to end up on the heap.</p>

<p>We can explore this using <code class="language-plaintext highlighter-rouge">go build -gcflags "-m"</code>. Let’s walk through an example.</p>

<p>First, let’s take some code that does the “wrong” thing and passes a small struct by pointer.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">package</span> <span class="n">alloc</span>

<span class="k">type</span> <span class="n">thing</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">A</span> <span class="kt">string</span>
	<span class="n">B</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doStuff</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">thing</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// do something with t</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">loadAndDoStuff</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">thing</span><span class="p">{}</span>
	<span class="n">t</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="s">"hello"</span>
	<span class="n">t</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="m">42</span>
	<span class="n">doStuff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Compiling with escape analysis we see that <code class="language-plaintext highlighter-rouge">&amp;thing{}</code> does not escape and will be stack allocated.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># alloc
./alloc.go:8:6: can inline doStuff
./alloc.go:12:6: can inline loadAndDoStuff
./alloc.go:16:9: inlining call to doStuff
./alloc.go:8:14: t does not escape
./alloc.go:13:7: &amp;thing{} does not escape
</code></pre></div></div>

<p>Now, let’s do the “right” thing by passing <code class="language-plaintext highlighter-rouge">thing{}</code> as a value, but let’s also interact with <code class="language-plaintext highlighter-rouge">json.Marshal()</code> and <code class="language-plaintext highlighter-rouge">fmt.Println()</code>.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="k">package</span> <span class="n">alloc</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"encoding/json"</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">thing</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">A</span> <span class="kt">string</span>
	<span class="n">B</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doStuff</span><span class="p">(</span><span class="n">t</span> <span class="n">thing</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">loadAndDoStuff</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">t</span> <span class="n">thing</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"A":"hello","B":42}`</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">doStuff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Escape analysis now shows that interacting with those commonly used functions causes our struct to escape to the heap. So, we have the worst of both worlds - no stack allocation, but we still end up copying <code class="language-plaintext highlighter-rouge">thing</code> when calling <code class="language-plaintext highlighter-rouge">doStuff()</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./alloc.go:13:6: can inline doStuff
./alloc.go:14:13: inlining call to fmt.Println
./alloc.go:23:9: inlining call to doStuff
./alloc.go:23:9: inlining call to fmt.Println
./alloc.go:13:14: leaking param: t
./alloc.go:14:13: ... argument does not escape
./alloc.go:14:14: t escapes to heap
./alloc.go:18:6: moved to heap: t
./alloc.go:19:31: ([]byte)(`{"A":"hello","B":42}`) escapes to heap
./alloc.go:23:9: ... argument does not escape
./alloc.go:23:9: t escapes to heap
</code></pre></div></div>

<p>So where does this leave us? I suggest a fairly simple set of heuristics that applies to both function parameters as well as method receivers. As always, there’ll be edge cases where these don’t work, but for most cases most of the time, these make a good baseline.</p>

<hr />

<ol>
  <li>
    <p><strong>Types that are not structs or arrays should be passed by value.</strong></p>
  </li>
  <li>
    <p><strong>Struct types that don’t export their members and are clearly built as immutable value types, like <code class="language-plaintext highlighter-rouge">time.Time</code>, should be passed by value. Note that these types are relatively rare, and are even rarer to be defined by you.</strong></p>
  </li>
  <li>
    <p><strong>Arrays and all other struct types should be passed by pointer, whether small, large, stateful, or whatever.</strong></p>
  </li>
  <li>
    <p><strong>If you’re passing data that could be mutated by a concurrent process and its important to you for that data not to be mutated, explicitly make a copy of it before passing it along. Be aware that you can’t just rely on passing the data by value since that does not create a deep copy.</strong></p>
  </li>
</ol>

<hr />

<p>I’ve personally followed basically these heuristics for years, and they line up well with lots of the Go standard library, but it’s nice to have some reasoned justification for them rather than just my intuition. Plus, in addition to working well in a lot of cases, I appreciate these heuristics for their simplicity–they leave little room for ad-hoc judgement calls and free up mental bandwidth for more difficult problems.</p>

      </article>

      

      

      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="/2023/09/04/the-monolith-vs-microservices-debate-misses-the-point.html" data-toggle="tooltip" data-placement="top" title="The Monolith vs Microservices Debate Misses the Point">&larr; Previous Post</a>
        </li>
        
        
      </ul>
      

    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"></ul>

      
      <p class="copyright text-muted">
      
        Percy Wegmann
        &nbsp;&bull;&nbsp;
      
      2023

      

      

      

      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
